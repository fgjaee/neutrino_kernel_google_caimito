/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * GXP user command interface.
 *
 * Copyright (C) 2022 Google LLC
 */

#ifndef __GXP_UCI_H__
#define __GXP_UCI_H__

#include <linux/kref.h>
#include <linux/kthread.h>

#include <gcip/gcip-fence-array.h>
#include <gcip/gcip-fence.h>
#include <gcip/gcip-mailbox.h>
#include <gcip/gcip-memory.h>

#include "gxp-client.h"
#include "gxp-internal.h"
#include "gxp-mailbox.h"
#include "gxp-vd.h"
#include "gxp.h"

#define UCI_RESOURCE_ID 0
#define UCI_CIRCULAR_QUEUE_WRAP_BIT BIT(15)

struct gxp_mcu;

/* Command/Response Structures */

/* Size of `gxp_uci_type` should be u8 to match FW */
enum gxp_uci_type {
	/* The command containing executable runtime command. */
	CORE_COMMAND = 0,
	/*
	 * Empty command that FW will simply respond to this command.
	 * Its purpose is to overcome the limitation of the number of in/out sync fences.
	 * From the perspective of KD, the communication logic with FW should be the same with
	 * RUNTIME_COMMAND.
	 */
	NULL_COMMAND = 1,
	/*
	 * The command to notify the IIF unblock.
	 * The firmware should check the fence table to see whether the fence has been unblocked
	 * normally or with an signal error.
	 */
	IIF_UNBLOCK_COMMAND = 2,
} __packed;

struct gxp_uci_wakelock_command_params {
	/* DVFS operating point of DSP cores */
	uint8_t dsp_operating_point;
	/* DVFS operating point of memory */
	uint8_t memory_operating_point;
};

struct gxp_uci_core_command_params {
	/* iova address of the app command */
	uint64_t address;
	/* size of the app command */
	uint32_t size;
	/* number of dsp cores required for this command */
	uint8_t num_cores;
	/* DVFS operating point of DSP cores */
	uint8_t dsp_operating_point;
	/* DVFS operating point of memory */
	uint8_t memory_operating_point;
};

struct gxp_uci_command {
	/* sequence number, should match the corresponding response */
	uint32_t seq;
	/* device address of the additional info */
	uint32_t additional_info_address;
	/* unique ID for each client that identifies client VM & security realm */
	uint32_t client_id;
	/* type of the command */
	enum gxp_uci_type type;
	/* reserved field */
	uint8_t reserved;
	/* size of the additional info */
	uint16_t additional_info_size;
	/* All possible command parameters */
	union {
		struct gxp_uci_core_command_params core_command_params;
		struct gxp_uci_wakelock_command_params wakelock_command_params;
		/* The ID of unblocked IIF will be passed when @type is IIF_UNBLOCK_COMMAND. */
		uint16_t iif_id;
		uint8_t opaque[48];
	};
};

/*
 * TODO(b/301608032): This additional_info must be generated by the litebuf once its C compiler
 * is implemented. Before that we should statiaclly define compatible structures here.
 *
 * +----------------------------------------+ <- 0
 * | struct gxp_uci_additional_info_header  |
 * +----------------------------------------+ <- root_offset
 * |                                        |  \
 * |                                        |  |
 * | struct gxp_uci_additional_info_root    |  | -> object_size
 * |                                        |  |
 * |                                        |  /
 * +----------------------------------------+ <- in_fences_offset
 * |                                        |
 * | uint16_t in_fences[in_fences_size]     |
 * |                                        |
 * +----------------------------------------+ <- out_fences_offset
 * |                                        |
 * | uint16_t out_fences[out_fences_size]   |
 * |                                        |
 * +----------------------------------------+ <- runtime_additional_info_offset
 * |                                        |
 * | uint8_t runtime_additional_info[       |
 * |     runtime_additional_info_size       |
 * | ]                                      |
 * |                                        |
 * +----------------------------------------+ <- additional_info_size
 */
struct gxp_uci_additional_info_header {
	/* Unique identifier to differentiate between multiple litebuf schemas. */
	uint8_t identifier;
	/* Unique version within a single schema. */
	uint8_t version;
	/* Reserved for alignment and future use. */
	uint8_t reserved[6];
	/* Pointer to the root object. */
	uint64_t root_offset;
} __packed;

struct gxp_uci_additional_info_root {
	/* The total size of this root object in bytes. */
	uint32_t object_size;
	/* The offset of the in_fences vector. */
	int32_t in_fences_offset;
	/* The number of elements in the in_fences vector. */
	uint32_t in_fences_size;
	/* The offset of the out_fences vector. */
	int32_t out_fences_offset;
	/* The number of elements in the out_fences vector. */
	uint32_t out_fences_size;
	/* Runtime specified timeout. */
	uint32_t timeout_ms;
	/* The offset of the runtime defined additional info buffer. */
	int32_t runtime_additional_info_offset;
	/* The size of the runtime defined additional info buffer in bytes. */
	uint32_t runtime_additional_info_size;
} __packed;

struct gxp_uci_additional_info {
	/* Header. */
	struct gxp_uci_additional_info_header header;
	/* Root. */
	struct gxp_uci_additional_info_root root;
	/* The pointer to in_fences of UCI command ioctl. */
	uint16_t *in_fences;
	/* The pointer to out_fences of UCI command ioctl. */
	uint16_t *out_fences;
	/* The pointer to runtime_additional_info of UCI command ioctl. */
	uint8_t *runtime_additional_info;
};

struct gxp_uci_response {
	/* sequence number, should match the corresponding command */
	uint64_t seq;
	/* unique ID for each client that identifies client VM & security realm*/
	uint32_t client_id;
	/* status code that tells the success or error. */
	uint16_t code;
	/* reserved field */
	uint8_t reserved[2];
	uint8_t opaque[16];
};

/*
 * Wrapper struct for responses consumed by a thread other than the one which
 * sent the command.
 */
struct gxp_uci_async_response {
	/*
	 * List entry which will be inserted to the waiting queue of the vd.
	 * It will be pushed into the waiting queue when the response is sent.
	 * (i.e, the `gxp_uci_push_cmd()` function is called)
	 * It will be poped when the response is consumed by the vd.
	 */
	struct list_head wait_list_entry;
	/*
	 * List entry which will be inserted to the dest_queue of the vd.
	 * It will be pushed into the dest_queue when the response is arrived or timed out.
	 * It will be poped when the response is consumed by the vd.
	 */
	struct list_head dest_list_entry;
	/* Stores the response. */
	struct gxp_uci_response resp;
	struct gxp_uci *uci;
	/* Queue where to be removed from once it is complete or timed out. */
	struct list_head *wait_queue;
	/* Queue to add the response to once it is complete or timed out. */
	struct list_head *dest_queue;
	/*
	 * The lock that protects queues pointed to by `dest_queue` and `wait_queue`.
	 * The mailbox code also uses this lock to protect changes to the `wait_queue` pointer
	 * itself when processing this response.
	 */
	spinlock_t *queue_lock;
	/* Queue of clients to notify when this response is processed. */
	wait_queue_head_t *dest_queue_waitq;
	/* gxp_eventfd to signal when the response completes. May be NULL. */
	struct gxp_eventfd *eventfd;
	/* The request was sent from this virtual device. */
	struct gxp_virtual_device *vd;
	/* Handles arrival, timeout of async response. */
	struct gcip_mailbox_resp_awaiter *awaiter;
	/* Status of the response. */
	enum gxp_response_status status;
	/* Additional info buffer. */
	struct gcip_memory additional_info_buf;
	/* In-fences. */
	struct gcip_fence_array *in_fences;
	/* Out-fences. */
	struct gcip_fence_array *out_fences;
	/* Will be set to true if the response has been processed. */
	bool processed;
	/* IIF which will be signaled once in-kernel fences of @in_fences are signaled. */
	struct iif_fence *iif_ikf;
};

struct gxp_uci {
	struct gxp_dev *gxp;
	struct gxp_mcu *mcu;
	struct gxp_mailbox *mbx;
	struct gcip_memory cmd_queue_mem;
	struct gcip_memory resp_queue_mem;
	struct gcip_memory descriptor_mem;
};

/* UCI APIs */

/**
 * gxp_uci_init() - API for initializing GXP UCI in MCU, should only be
 * called while initializing MCU
 * @mcu: The MCU that UCI communicate with
 *
 * Return:
 * * 0       - Initialization finished successfully
 * * -ENOMEM - Cannot get memory to finish init.
 */
int gxp_uci_init(struct gxp_mcu *mcu);

/**
 * gxp_uci_reinit() - Re-initializes the initialized UCI object.
 * @uci: The UCI to be initialized
 *
 * Return:
 * * 0       - Initialization finished successfully
 */
int gxp_uci_reinit(struct gxp_uci *uci);

/**
 * gxp_uci_exit() - API for releasing the UCI mailbox of MCU.
 * @uci: The UCI to be released
 */
void gxp_uci_exit(struct gxp_uci *uci);

/*
 * gxp_uci_wait_async_response() - API for waiting and fetching a response from
 * MCU firmware.
 *
 * Returns 0 on success, a negative errno on failure.
 */
int gxp_uci_wait_async_response(struct mailbox_resp_queue *uci_resp_queue,
				u64 *resp_seq, u16 *error_code, u8 *opaque);

/*
 * gxp_uci_fill_additional_info() - Fills @info according to the passed additional information.
 * It is expected that the filled @info will be passed to the `gxp_uci_push_cmd()`.
 */
void gxp_uci_fill_additional_info(struct gxp_uci_additional_info *info, uint16_t *in_fences,
				  uint32_t in_fences_size, uint16_t *out_fences,
				  uint32_t out_fences_size, uint32_t timeout_ms,
				  uint8_t *runtime_additional_info,
				  uint32_t runtime_additional_info_size);

/**
 * gxp_uci_send_cmd() - Sends an UCI command to the firmware.
 * @client: The client sending the command.
 * @cmd_seq: The command sequence number.
 * @flags: The command flags passed from the UCI command ioctl. (See gxp_mailbox_uci_command_ioctl)
 * @opaque: The runtime command. (See gxp_mailbox_uci_command_ioctl)
 * @timeout_ms: The command timeout. If 0, the default one (MAILBOX_TIMEOUT) will be used. Note
 *              that, if it is specified, the driver will add a margin (PER_CMD_TIMEOUT_MARGIN_MS).
 *              It is to give enough time to the firmware side and let them return a timeout
 *              response to the driver instead of processing the command as timeout from the kernel
 *              level.
 * @in_fences: The in-fences that the command will wait on. Note that the command will be always
 *             pended in the firmware level even though there are in-kernel fences. If there are
 *             in-kernel fences, the driver will submit the command to the firmware first and then
 *             notify the firmware of the in-kernel fence unblock later. Note that @timeout_ms will
 *             be also used for waiting on in-kernel fences.
 * @out_fences: The out-fences which will be signaled once the command is processed.
 *
 * This function should be called in the ioctl function only, where the `gxp_client_destroy()` is
 * guaranteed not to be called simultaneously.
 *
 * Return: 0 on success or errno on failure.
 */
int gxp_uci_send_cmd(struct gxp_client *client, u64 cmd_seq, u32 flags, const u8 *opaque,
		     u32 timeout_ms, struct gcip_fence_array *in_fences,
		     struct gcip_fence_array *out_fences);

/*
 * TODO(b/395523291): Remove @gxp_uci_send_iif_unblock_noti() once IIF signalling mailbox available.
 */
/**
 * gxp_uci_send_iif_unblock_noti() - Sends the fence unblock notification of @iif_id fence to the
 *                                   MCU firmware.
 *
 * @uci: The UCI mailbox to send notification to the MCU firmware.
 * @iif_id: The ID of the unblocked IIF.
 *
 * Note that this function will be called when the fence has been unblocked and the IIF driver calls
 * the unblocked callback.
 */
void gxp_uci_send_iif_unblock_noti(struct gxp_uci *uci, int iif_id);

/**
 * gxp_uci_consume_responses() - Consumes all responses arrived from the firmware.
 *
 * @uci: The UCI mailbox.
 */
void gxp_uci_consume_responses(struct gxp_uci *uci);

/**
 * gxp_uci_cancel() - Cancels all pending UCI commands in the waiting queue of @vd.
 * @vd: The virtual device which is going to cancel all of its UCI commands.
 * @client_id: The client ID of @vd.
 * @reason: The reason to cancel UCI commands of @vd. (GXP_INVALIDATED_*)
 *
 * This function should be called not only when the client won't send more commands anymore, but
 * also the MCU won't return any responses of commands of @vd anymore. For example,
 *  - @vd released the block wakelock and the `RELEASE_VMBOX` KCI has been sent to the MCU.
 *  - The MCU crashed and @vd had been invalidated.
 *
 * Also, before calling this function, it is recommended to call the `gxp_uci_consume_responses`
 * function to prevent a race condition canceling pending commands whose responses have already
 * arrived from the MCU, but not consumed yet. Otherwise, from the MCU perspective, the commands
 * were processed well, but from the kernel/runtime perspective, those commands can be considered
 * as canceled.
 */
void gxp_uci_cancel(struct gxp_virtual_device *vd, int client_id, u32 reason);

#endif /* __GXP_UCI_H__ */
